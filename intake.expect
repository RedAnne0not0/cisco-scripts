#!/usr/bin/expect -f

# Cisco Device Intake Script
# Usage: ./intake.expect <device-name> <device-type> [serial-port]
# Example: ./intake.expect switch1 switch /dev/ttyUSB0
# Device types: switch, router

###############################################################################
# Helper procedures
###############################################################################

#––– enter_enable – escalate to privileged EXEC, optional ENABLEPW –––
proc enter_enable {} {
    expect {
        -re {>\s*$} {
            send -- "enable\r"
            expect {
                -re {Password:\s*$} {
                    if {[info exists ::env(ENABLEPW)]} {
                        send -- "$::env(ENABLEPW)\r"
                    } else {
                        stty -echo
                        send_user "\nEnable password: "
                        expect_user -re "(.*)\n"
                        stty echo
                        send -- "$expect_out(1,string)\r"
                    }
                    expect {
                        -re {#\s*$} { }
                        timeout { 
                            stty echo  
                            send_user "Enable password failed\n"
                        }
                    }
                }
                -re {#\s*$} { }   ;# no password set
            }
        }
        -re {#\s*$} { }           ;# already privileged
    }
}

#––– run_cmd – timestamp, send, capture common CLI errors –––
proc run_cmd {cmd} {
    set ts [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]
    send_user "$ts  >> $cmd\n"
    send -- "$cmd\r"
    expect {
        -re {\r\n% (Invalid|Ambiguous|Incomplete).*} {
            send_user "ERROR: $expect_out(0,string)\n"
            exp_continue
        }
        -re {#\s*$}   { return }
        timeout       { send_user "TIMEOUT on $cmd\n" }
    }
}

# Check arguments
if {$argc < 2} {
    puts "Usage: $argv0 <device-name> <device-type> \[serial-port\]"
    puts "Example: $argv0 switch1 switch /dev/ttyUSB0"
    puts "         $argv0 router1 router /dev/ttyUSB1"
    puts "Device types: switch, router"
    puts "Default serial port: /dev/ttyUSB0"
    exit 1
}

set device [lindex $argv 0]
set device_type [lindex $argv 1]
set serial_port "/dev/ttyUSB0"

if {$argc >= 3} {
    set serial_port [lindex $argv 2]
}

# Validate device type
if {$device_type != "switch" && $device_type != "router"} {
    puts "Error: device-type must be 'switch' or 'router'"
    puts "You provided: $device_type"
    exit 1
}

set timeout 30
set output_file "${device}-intake-[clock format [clock seconds] -format %Y%m%d-%H%M%S].txt"

puts "Starting intake for device: $device"
puts "Device type: $device_type" 
puts "Serial port: $serial_port"
puts "Output file: $output_file"
puts "----------------------------------------"

#spawn minicom -D $serial_port -b 9600 -8 -o ## Don't use minicom, it's an interactive terminal emulator and adds its own layer of control 
spawn -open [open $serial_port r+]  # create a direct connection to the serial port
## The line above worked in hacking the code during testing but after adding to branch does not seem to work
## 2 lines immediately below are the attempted fix
## set serial_fd [open $serial_port r+]
spawn -open $serial_fd
sleep 1 # attempting to find a problem
# stty -F $serial_port 9600 cs8 -cstopb -parenb # set the serial port parameters (9600 baud, 8 data bits, no stop bits, no parity)
if {[catch {exec stty -F $serial_port 9600 cs8 -cstopb -parenb} result]} {
    puts "Warning: stty configuration failed: $result"
}
log_file $output_file

# Handle initial boot prompts and connection
expect {
    "initial configuration dialog" {
        send "no\r"
        exp_continue
    }
    "terminate autoinstall" {
        send "yes\r"
        exp_continue
    }
    "Press RETURN to get started" {
        send "\r"
        exp_continue
    }
    "Username:" {
        send "\r"
        exp_continue
    }
    "Password:" {
        send "\r"
        exp_continue
    }
    ">" {
        # User mode prompt - good to proceed
    }
    "#" {
        # Already in privileged mode - good to proceed
    }
    timeout {
        puts "Timeout waiting for prompt, sending Enter..."
        send "\r"
        exp_continue
    }
}

# Wait for initial prompt before trying to escalate
# expect -re {[\]>#]\s*$} ## bad regex, was intended to wait for `>` to call `enter_enable` but if `>` is obtained before this, it doesn't recognize it 

# Get to privileged mode
enter_enable

# Set terminal parameters
send "terminal length 0\r"
expect "#"
send "terminal width 512\r"
expect "#"

puts "Connected and configured terminal settings"
puts "Running intake commands..."

# First clock capture + RTC sanity check
run_cmd "show clock detail"

# Define intake commands based on device type
if {$device_type == "switch"} {
    set commands {
        "show version"
        "show boot"
        "show startup-config"
        "show vlan brief"
        "show running-config | include hostname"
        "dir flash:"
        "show inventory"
        "show sdm prefer"
        "show env all"
        "show interfaces status"
        "show ip interface brief"
        "show post"
        "show processes cpu history"
        "show memory statistics"
        "show license udi"
        "show license all"
    }
    
    # Add stack commands - these will error gracefully on non-stackable switches
    lappend commands "show switch detail"
    lappend commands "show stack-power"
    lappend commands "show switch stack-ring speed"
    
    puts "Using switch command set"
} elseif {$device_type == "router"} {
    set commands {
        "show version"
        "show bootvar"
        "show startup-config"
        "show running-config | include hostname"
        "dir bootflash:"
        "show inventory"
        "show platform"
        "show license udi"
        "show license all"
        "show environment all"
        "show diag"
        "show processes cpu history"
        "show memory statistics"
        "dir usb0:"
        "show rom-monitor"
    }
    puts "Using router command set"
}

# Execute all commands
foreach cmd $commands { 
    run_cmd $cmd 
}

# Final clock capture
run_cmd "show clock detail"

puts "All commands completed"
puts "Cleaning up..."

# Exit gracefully
send "exit\r"
expect eof

puts "----------------------------------------"
puts "Intake completed successfully!"
puts "Output saved to: $output_file"

# Display file size and line count
catch {exec wc -l $output_file} result
puts "File statistics: $result"
